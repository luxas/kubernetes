// YAMLDocumentSeparator is the separator between YAML documents
const YAMLDocumentSeparator = "---\n"

// ConfigSerializer provides encoding/decoding for a configuration file
type ConfigSerializer interface {
	DecodeInto([]byte, runtime.Object) error
	DecodeManyInto(EncodedConfigs, DecodedConfigs) error
	Encode(EncodingFormat, schema.GroupVersion, runtime.Object) ([]byte, error)
	EncodeMany(EncodingFormat, DecodedConfigs) ([]byte, error)
}


// DecodeManyInto decodes bytes into a pointer of the desired type
func (cs *configSerializer) DecodeManyInto(src EncodedConfigs, dest DecodedConfigs) error {
	for gvk, file := range src {
		into, ok := dest[gvk]
		if !ok {
			return fmt.Errorf("src and dest aren't equal")
		}
		if err := cs.DecodeInto(file, into); err != nil {
			return err
		}
	}
	return nil
}

// EncodeMany encodes multiple inputs in a gvk-object map into a byte slice where the objects are encoded as multiple YAML documents
func (cs *configSerializer) EncodeMany(format EncodingFormat, objs DecodedConfigs) ([]byte, error) {
	docs := EncodedConfigs{}
	for gvk, obj := range objs {
		b, err := cs.Encode(format, gvk.GroupVersion(), obj)
		if err != nil {
			return nil, err
		}
		if err := docs.Add(gvk, b); err != nil {
			return nil, err
		}
	}
	return docs.GetAllDocuments(), nil
}

// DecodedConfigs represents a collection of decoded configuration files.
// The objects are indexed by their GroupVersionKind.
type DecodedConfigs map[schema.GroupVersionKind]runtime.Object

// EncodedConfigs represents a collection of byte-encoded configuration files.
// The different byte slices are indexed by their GroupVersionKind. The kind name
// is unique per set.
type EncodedConfigs map[schema.GroupVersionKind][]byte

// Add adds a new file to the set, but enforces that kind name is unique across the set
func (ec *EncodedConfigs) Add(gvk schema.GroupVersionKind, b []byte) error {
	// Enforce that kind is unique across this
	for existinggvk := range *ec {
		if existinggvk.Kind == gvk.Kind {
			return fmt.Errorf("kind %q is specified twice in YAML file", gvk.Kind)
		}
	}
	(*ec)[gvk] = b
	return nil
}

// GetAllDocuments returns all documents in the set, in alphabetical order based on their kind,
// separated by the YAML document separator.
func (ec *EncodedConfigs) GetAllDocuments() []byte {
	kinds := []string{}
	kindMap := map[string]schema.GroupVersionKind{}
	sortedContent := [][]byte{}
	for gvk := range *ec {
		kinds = append(kinds, gvk.Kind)
		kindMap[gvk.Kind] = gvk
	}
	sort.Strings(kinds)
	for _, kind := range kinds {
		sortedContent = append(sortedContent, (*ec)[kindMap[kind]])
	}

	return bytes.Join(sortedContent, []byte(YAMLDocumentSeparator))
}

// ReadConfigSource reads a source string, which is a comma-delimited string that can point to multiple
// configuration files, or directories with JSON or YAML files. Every source file may contain multiple
// YAML documents
func ReadConfigSource(srcString string) (EncodedConfigs, error) {
	srcs := strings.Split(srcString, ",")
	result := EncodedConfigs{}
	for _, src := range srcs {
		files, err := ReadFileOrDirectory(src)
		if err != nil {
			return nil, err
		}
		for _, file := range files {
			gvkmap, err := SplitYAMLDocuments(file)
			if err != nil {
				return nil, err
			}
			for gvk, doc := range gvkmap {
				if err := result.Add(gvk, doc); err != nil {
					return nil, err
				}
			}
		}
	}
	return result, nil
}

// ReadFileOrDirectory reads a file or directory, and returns a slice of files.
func ReadFileOrDirectory(src string) ([][]byte, error) {
	// TODO: Check if src is a directory, for now assume it's a file
	files := [][]byte{}
	b, err := ioutil.ReadFile(src)
	if err != nil {
		return nil, err
	}
	files = append(files, b)
	return files, nil
}

// SplitYAMLDocuments reads the YAML bytes per-document, unmarshals the TypeMeta information from each document
// and returns a map between the GroupVersionKind of the document and the document bytes
func SplitYAMLDocuments(yamlBytes []byte) (EncodedConfigs, error) {
	gvkmap := EncodedConfigs{}
	errs := []error{}
	buf := bytes.NewBuffer(yamlBytes)
	reader := utilyaml.NewYAMLReader(bufio.NewReader(buf))
	for {
		// Read one YAML document at a time, until io.EOF is returned
		b, err := reader.Read()
		if err == io.EOF {
			break
		} else if err != nil {
			return nil, err
		}
		if len(b) == 0 {
			break
		}

		// Get the TypeMeta information of this file
		gvkPtr, err := defaultYAMLMetaFactory.Interpret(b)
		if err != nil {
			errs = append(errs, err)
			continue
		}

		if err := gvkmap.Add(*gvkPtr, b); err != nil {
			errs = append(errs, err)
		}
	}
	if err := errorsutil.NewAggregate(errs); err != nil {
		return nil, err
	}
	return gvkmap, nil
}

func TestEncodeMany(t *testing.T) {
	m := DecodedConfigs{
		extgv.WithKind("Simple"):  &runtimetest.InternalSimple{TestString: "foo"},
		extgv.WithKind("Complex"): &runtimetest.InternalComplex{String: "bar"},
	}
	b, err := cfgserializer.EncodeMany(YAML, m)
	t.Error(string(b), err)
}

var bothSimpleAndComplex = []byte(string(oneComplex) + YAMLDocumentSeparator + string(oneSimple))

func TestDecodeMany(t *testing.T) {
	in := EncodedConfigs{
		intgv.WithKind("Simple"):  oneSimple,
		intgv.WithKind("Complex"): oneComplex,
	}
	simple := &runtimetest.InternalSimple{}
	complex := &runtimetest.InternalComplex{}
	out := DecodedConfigs{
		intgv.WithKind("Simple"):  simple,
		intgv.WithKind("Complex"): complex,
	}
	err := cfgserializer.DecodeManyInto(in, out)
	t.Error(*simple, *complex, err)
}

func TestRoundtripMany(t *testing.T) {
	in := EncodedConfigs{
		extgv.WithKind("Simple"):  oneSimple,
		extgv.WithKind("Complex"): oneComplex,
	}
	simple := &runtimetest.InternalSimple{}
	complex := &runtimetest.InternalComplex{}
	out := DecodedConfigs{
		extgv.WithKind("Simple"):  simple,
		extgv.WithKind("Complex"): complex,
	}
	err := cfgserializer.DecodeManyInto(in, out)
	b, err := cfgserializer.EncodeMany(YAML, out)
	t.Errorf("%t\n%s\n%s\n%v", bytes.Equal(b, bothSimpleAndComplex), string(bothSimpleAndComplex), string(b), err)
}

func TestSplitYAMLDocuments(t *testing.T) {
	expectedcfs := EncodedConfigs{
		extgv.WithKind("Simple"):  oneSimple,
		extgv.WithKind("Complex"): oneComplex,
	}
	cfs, err := SplitYAMLDocuments(bothSimpleAndComplex)
	t.Errorf("%t\n%v", reflect.DeepEqual(cfs, expectedcfs), err)
}